require("data.table")
require("rpart")
require("rpart.plot")
#Aqui se debe poner la carpeta de la materia de SU computadora local
setwd("C:/Users/lnfernandez/Desktop/posgrado/DM EyN/DM-EyF")  #Establezco el Working Directory
remove(list=ls())
#cargo el dataset
dataset  <- fread("./datasets/competencia1_2022.csv")
semillas <- c(100621,
102149,
202061,
257093,
584723)
# Creamos una clase binaria
dataset[, clase_binaria := ifelse(
clase_ternaria == "BAJA+2",
"evento",
"noevento"
)]
# Borramos el target viejo
dataset[, clase_ternaria := NULL]
# paso a factor categoricas
did_recode_columns <- function(dt, cols, type = c("as.numeric", "as.factor", "as.character", "as.interger", "as.double") ) {
# function used to convert data.table columns
# to factor, numeric, or character
library(data.table)
dt[,(cols) := lapply(.SD, type), .SDcols = cols]
}
variables_factor <-c("cliente_vip", "internet", "tcuentas", "cdescubierto_preacordado", "active_quarter",
"Master_status", "Master_delinquency",
"Visa_status", "Visa_delinquency",
"tmobile_app","thomebanking","tcallcenter", "ccaja_seguridad"
)
did_recode_columns(dataset, variables_factor, type = "as.factor")
dtrain  <- dataset[ foto_mes==202101 ]  #defino donde voy a entrenar
dapply  <- dataset[ foto_mes==202103 ]  #defino donde voy a aplicar el modelo
hist(log(dtrain$mcuenta_corriente))
hist(log(dapply$ctrx_quarter))
base<-dapply
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
readRDS("bayesianas.rds")->bayesianas
print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
# Medimos cuanto tarda nuestro modelo en ajustar
resultados<-c()
for (semilla in semillas) {
set.seed(semilla)
in_training <- caret::createDataPartition(dtrain_m$clase_binaria,
p = 0.70, list = FALSE)
dtrain2  <-  dtrain[in_training, ]
dtest   <-  dtrain[-in_training, ]
pred_training <- predict(modeloTodas, dtrain2, type = "prob")
pred_testing <- predict(modeloTodas, dtest, type = "prob")
# Armamos una función que nos calcule la ganancia, usando el punto de corte de
# 0.025
ganancia <- function(probabilidades, clase) {
return(sum(
(probabilidades >= 0.025) * ifelse(clase == "evento", 78000, -2000))
)
}
gan<-ganancia(pred_testing[, "evento"], dtest$clase_binaria) / 0.3
# La ganancia en testing NORMALIZADA
print(gan)
c(resultados,gan)->resultados
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
readRDS("bayesianas.rds")->bayesianas
print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
# Medimos cuanto tarda nuestro modelo en ajustar
resultados<-c()
for (semilla in semillas) {
set.seed(semilla)
in_training <- caret::createDataPartition(dtrain_m$clase_binaria,
p = 0.70, list = FALSE)
dtrain2  <-  dtrain[in_training, ]
dtest   <-  dtrain[-in_training, ]
pred_training <- predict(modeloTodas, dtrain2, type = "prob")
pred_testing <- predict(modeloTodas, dtest, type = "prob")
# Armamos una función que nos calcule la ganancia, usando el punto de corte de
# 0.025
ganancia <- function(probabilidades, clase) {
return(sum(
(probabilidades >= 0.025) * ifelse(clase == "evento", 78000, -2000))
)
}
gan<-ganancia(pred_testing[, "evento"], dtest$clase_binaria) / 0.3
# La ganancia en testing NORMALIZADA
print(gan)
c(resultados,gan)->resultados
}
for (semilla in semillas) {
set.seed(semilla)
in_training <- caret::createDataPartition(dtrain_m$clase_binaria,
p = 0.70, list = FALSE)
dtrain2  <-  dtrain_m[in_training, ]
dtest   <-  dtrain_m[-in_training, ]
pred_training <- predict(modeloTodas, dtrain2, type = "prob")
pred_testing <- predict(modeloTodas, dtest, type = "prob")
# Armamos una función que nos calcule la ganancia, usando el punto de corte de
# 0.025
ganancia <- function(probabilidades, clase) {
return(sum(
(probabilidades >= 0.025) * ifelse(clase == "evento", 78000, -2000))
)
}
gan<-ganancia(pred_testing[, "evento"], dtest$clase_binaria) / 0.3
# La ganancia en testing NORMALIZADA
print(gan)
c(resultados,gan)->resultados
}
print(mean(resultados))
base[ , tipo2 :=minversion2/cinversion2]
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
base[ , tipo2 :=minversion2/cinversion2]
base[ , C_Seguros :=  cseguro_vida+cseguro_auto+cseguro_vivienda+cseguro_accidentes_personales]
base[ , media_slarioss :=mpayroll/cpayroll_trx]
base[ , media_haberes :=mpayroll2/cpayroll_trx2]
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll_trx2+cpayroll_trx)]
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
#cargo el dataset
dataset  <- fread("./datasets/competencia1_2022.csv")
View(dataset)
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
base[ , tipo2 :=minversion2/cinversion2]
base[ , C_Seguros :=  cseguro_vida+cseguro_auto+cseguro_vivienda+cseguro_accidentes_personales]
base[ , media_slarioss :=mpayroll/cpayroll_trx]
base[ , media_haberes :=mpayroll2/cpayroll2_trx]
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll2_trx+cpayroll_trx)]
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
readRDS("bayesianas.rds")->bayesianas
#readRDS("bayesianas.rds")->bayesianas
#print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
View(importancia)
View(importancia)
# Medimos cuanto tarda nuestro modelo en ajustar
resultados<-c()
for (semilla in semillas) {
set.seed(semilla)
in_training <- caret::createDataPartition(dtrain_m$clase_binaria,
p = 0.70, list = FALSE)
dtrain2  <-  dtrain_m[in_training, ]
dtest   <-  dtrain_m[-in_training, ]
pred_training <- predict(modeloTodas, dtrain2, type = "prob")
pred_testing <- predict(modeloTodas, dtest, type = "prob")
# Armamos una función que nos calcule la ganancia, usando el punto de corte de
# 0.025
ganancia <- function(probabilidades, clase) {
return(sum(
(probabilidades >= 0.025) * ifelse(clase == "evento", 78000, -2000))
)
}
gan<-ganancia(pred_testing[, "evento"], dtest$clase_binaria) / 0.3
# La ganancia en testing NORMALIZADA
print(gan)
c(resultados,gan)->resultados
}
print(mean(resultados))
View(dtrain_m)
View(importancia)
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll2_trx+cpayroll_trx)]
base[ is.nan(media_ingresos), media_ingresos :=0]
View(base)
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
base[ , tipo2 :=minversion2/cinversion2]
base[ , C_Seguros :=  cseguro_vida+cseguro_auto+cseguro_vivienda+cseguro_accidentes_personales]
base[ , media_salarios :=mpayroll/cpayroll_trx]
base[ , media_haberes :=mpayroll2/cpayroll2_trx]
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll2_trx+cpayroll_trx)]
base[ is.nan(media_ingresos), media_ingresos :=0]
base[ is.nan(media_haberes), media_haberes :=0]
base[ is.nan(media_salarios), media_salarios :=0]
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
#readRDS("bayesianas.rds")->bayesianas
#print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
View(importancia)
# Medimos cuanto tarda nuestro modelo en ajustar
resultados<-c()
for (semilla in semillas) {
set.seed(semilla)
in_training <- caret::createDataPartition(dtrain_m$clase_binaria,
p = 0.70, list = FALSE)
dtrain2  <-  dtrain_m[in_training, ]
dtest   <-  dtrain_m[-in_training, ]
pred_training <- predict(modeloTodas, dtrain2, type = "prob")
pred_testing <- predict(modeloTodas, dtest, type = "prob")
# Armamos una función que nos calcule la ganancia, usando el punto de corte de
# 0.025
ganancia <- function(probabilidades, clase) {
return(sum(
(probabilidades >= 0.025) * ifelse(clase == "evento", 78000, -2000))
)
}
gan<-ganancia(pred_testing[, "evento"], dtest$clase_binaria) / 0.3
# La ganancia en testing NORMALIZADA
print(gan)
c(resultados,gan)->resultados
}
print(mean(resultados))
base[ , C_debitos :=  ccuenta_debitos_automaticos+ctarjeta_visa_debitos_automaticos+ctarjeta_master_debitos_automaticos]
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
base[ , tipo2 :=minversion2/cinversion2]
base[ , C_Seguros :=  cseguro_vida+cseguro_auto+cseguro_vivienda+cseguro_accidentes_personales]
base[ , C_debitos :=  ccuenta_debitos_automaticos+ctarjeta_visa_debitos_automaticos+ctarjeta_master_debitos_automaticos]
base[ , C_descuentos :=  ccajeros_propios_descuentos+ctarjeta_master_descuentos+ctarjeta_visa_descuentos]
base[ , M_descuentos :=  mtarjeta_visa_descuentos+mtarjeta_master_descuentos+mcajeros_propios_descuentos]
base[ , media_descuentos :=  M_descuentos/C_descuentos]
base[ , media_salarios :=mpayroll/cpayroll_trx]
base[ , media_haberes :=mpayroll2/cpayroll2_trx]
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll2_trx+cpayroll_trx)]
base[ is.nan(media_ingresos), media_ingresos :=0]
base[ is.nan(media_haberes), media_haberes :=0]
base[ is.nan(media_salarios), media_salarios :=0]
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
#readRDS("bayesianas.rds")->bayesianas
#print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
# Medimos cuanto tarda nuestro modelo en ajustar
resultados<-c()
for (semilla in semillas) {
set.seed(semilla)
in_training <- caret::createDataPartition(dtrain_m$clase_binaria,
p = 0.70, list = FALSE)
dtrain2  <-  dtrain_m[in_training, ]
dtest   <-  dtrain_m[-in_training, ]
pred_training <- predict(modeloTodas, dtrain2, type = "prob")
pred_testing <- predict(modeloTodas, dtest, type = "prob")
# Armamos una función que nos calcule la ganancia, usando el punto de corte de
# 0.025
ganancia <- function(probabilidades, clase) {
return(sum(
(probabilidades >= 0.025) * ifelse(clase == "evento", 78000, -2000))
)
}
gan<-ganancia(pred_testing[, "evento"], dtest$clase_binaria) / 0.3
# La ganancia en testing NORMALIZADA
print(gan)
c(resultados,gan)->resultados
}
print(mean(resultados))
View(importancia)
rownames(importancia)->importancia$variable
View(importancia)
View(dtrain2)
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
base[ , tipo2 :=minversion2/cinversion2]
base[ , C_Seguros :=  cseguro_vida+cseguro_auto+cseguro_vivienda+cseguro_accidentes_personales]
base[ , C_debitos :=  ccuenta_debitos_automaticos+ctarjeta_visa_debitos_automaticos+ctarjeta_master_debitos_automaticos]
base[ , C_descuentos :=  ccajeros_propios_descuentos+ctarjeta_master_descuentos+ctarjeta_visa_descuentos]
base[ , M_descuentos :=  mtarjeta_visa_descuentos+mtarjeta_master_descuentos+mcajeros_propios_descuentos]
base[ , media_descuentos :=  M_descuentos/C_descuentos]
base[ , media_salarios :=mpayroll/cpayroll_trx]
base[ , media_haberes :=mpayroll2/cpayroll2_trx]
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll2_trx+cpayroll_trx)]
base[ is.nan(media_ingresos), media_ingresos :=0]
base[ is.nan(media_haberes), media_haberes :=0]
base[ is.nan(media_salarios), media_salarios :=0]
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
#readRDS("bayesianas.rds")->bayesianas
#print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
rownames(importancia)->importancia$variable
View(importancia)
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
base[ , tipo2 :=minversion2/cinversion2]
base[ , C_Seguros :=  cseguro_vida+cseguro_auto+cseguro_vivienda+cseguro_accidentes_personales]
base[ , C_debitos :=  ccuenta_debitos_automaticos+ctarjeta_visa_debitos_automaticos+ctarjeta_master_debitos_automaticos]
base[ , C_descuentos :=  ccajeros_propios_descuentos+ctarjeta_master_descuentos+ctarjeta_visa_descuentos]
base[ , M_descuentos :=  mtarjeta_visa_descuentos+mtarjeta_master_descuentos+mcajeros_propios_descuentos]
base[ , media_descuentos :=  M_descuentos/C_descuentos]
base[ , media_salarios :=mpayroll/cpayroll_trx]
base[ , media_haberes :=mpayroll2/cpayroll2_trx]
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll2_trx+cpayroll_trx)]
base[ is.nan(media_ingresos), media_ingresos :=0]
base[ is.nan(media_haberes), media_haberes :=0]
base[ is.nan(media_salarios), media_salarios :=0]
base[ is.nan(media_descuentos), media_salarios :=0]
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
#readRDS("bayesianas.rds")->bayesianas
#print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
rownames(importancia)->importancia$variable
# Medimos cuanto tarda nuestro modelo en ajustar
resultados<-c()
for (semilla in semillas) {
set.seed(semilla)
in_training <- caret::createDataPartition(dtrain_m$clase_binaria,
p = 0.70, list = FALSE)
dtrain2  <-  dtrain_m[in_training, ]
dtest   <-  dtrain_m[-in_training, ]
pred_training <- predict(modeloTodas, dtrain2, type = "prob")
pred_testing <- predict(modeloTodas, dtest, type = "prob")
# Armamos una función que nos calcule la ganancia, usando el punto de corte de
# 0.025
ganancia <- function(probabilidades, clase) {
return(sum(
(probabilidades >= 0.025) * ifelse(clase == "evento", 78000, -2000))
)
}
gan<-ganancia(pred_testing[, "evento"], dtest$clase_binaria) / 0.3
# La ganancia en testing NORMALIZADA
print(gan)
c(resultados,gan)->resultados
}
print(mean(resultados))
View(importancia)
View(dtrain2)
aplicarCambios<-function(base){
base$foto_mes<-NULL
base$nulos<-apply(X = is.na(base), MARGIN = 1, FUN = sum)
base$log_ctrx_quarter<-log(base$ctrx_quarter)
base$moroso2<-paste0(base$Visa_delinquency, base$Master_delinquency)
#base$cierre2<-paste0(base$Visa_status, base$Master_status)
#base$cierres<-ifelse(base$Visa_status %in% c(6,7,9) & base$Master_status %in% c(6,7,9),1,0)
variables_factor2 <-c(  "moroso2"
#,"cierre2"
#,"cierres"
)
base[ , tipo2 :=minversion2/cinversion2]
base[ , C_Seguros :=  cseguro_vida+cseguro_auto+cseguro_vivienda+cseguro_accidentes_personales]
base[ , C_debitos :=  ccuenta_debitos_automaticos+ctarjeta_visa_debitos_automaticos+ctarjeta_master_debitos_automaticos]
base[ , C_descuentos :=  ccajeros_propios_descuentos+ctarjeta_master_descuentos+ctarjeta_visa_descuentos]
base[ , M_descuentos :=  mtarjeta_visa_descuentos+mtarjeta_master_descuentos+mcajeros_propios_descuentos]
base[ , media_descuentos :=  M_descuentos/C_descuentos]
base[ , media_salarios :=mpayroll/cpayroll_trx]
base[ , media_haberes :=mpayroll2/cpayroll2_trx]
base[ , media_ingresos :=(mpayroll2+mpayroll)/(cpayroll2_trx+cpayroll_trx)]
base[ is.nan(media_ingresos), media_ingresos :=0]
base[ is.nan(media_haberes), media_haberes :=0]
base[ is.nan(media_salarios), media_salarios :=0]
base[ is.nan(media_descuentos), media_descuentos :=0]
base[ is.nan(tipo2), tipo2 :=0]
did_recode_columns(base, variables_factor2, type = "as.factor")
return(base)
}
dtrain_m<-aplicarCambios(dtrain)
dapply_m<-aplicarCambios(dapply)
#readRDS("bayesianas.rds")->bayesianas
#print(bayesianas)
# todas las variables
modeloTodas  <- rpart(formula=   "clase_binaria ~ .",  #quiero predecir clase_ternaria a partir de el resto de las variables
data=      dtrain_m,  #los datos donde voy a entrenar
xval=      0,
cp=       -1,   #esto significa no limitar la complejidad de los splits
minsplit=  13,     #minima cantidad de registros para que se haga el split
minbucket= 4,     #tamaÃ±o minimo de una hoja
maxdepth=  6 )    #profundidad maxima del arbol
as.data.frame(modeloTodas$variable.importance)->importancia
rownames(importancia)->importancia$variable
View(importancia)
dtrain2[is.na(M_descuentos) & !is.na(C_descuentos)]->vers
View(vers)
dtrain2[is.na(M_descuentos) & !is.na(C_descuentos), .(M_descuentos,C_descuentos, mtarjeta_visa_descuentos, ctarjeta_visa_descuentos, mtarjeta_master_descuentos,ctarjeta_master_descuentos, mcajeros_propios_descuentos, ccajeros_propios_descuentos)]->vers
View(vers)
